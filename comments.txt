Analysis of Part A, Alistair Moffat Appreciation Society
Amy Rieck and Luke Hedt

1. Moves Calculation Analysis:
Let     S := Number of Board Spaces (It's 64 but hey)
        P_b := Number of Black Pieces
        P_w := Number of White Pieces

The board is scanned once for each player to determine where their pieces are.
Time:
    Determining Locations  = O(2 * S)
Space:
    Determining Locatoins = O(S + P_b + P_w)

Each piece is tested in every direction for valid moves
For White:
    Time:
        Finding Valid Moves = O(4 * P_w)
    Space:
        Finding Valid Moves = O(4 * P_w)

For Black:
    Time:
        Finding Valid Moves = O(4 * P_b)
    Space:
        Finding Valid Moves = O(4 * P_b)

Therefore, once read in, the complexity of finding all valid moves is:
    Time:
        O(2 * S) + O(4 * P_w) + O(4 * P_b)
            = O(2*S + 4(P_w + P_b))
                Which is Linear

    Space:
        O(S + P_b + P_w) + O(4 * P_w) + O(4 * P_b)
            = O(S + 5(P_w + P_b))
                Which is Linear

2. Massacre Analysis
2.1 How have you modelled the problem as a search problem?
    The formalised problem:
        Goals:
            The Number of Black Pieces = 0
        States:
            The board state (as an 8x8 Array)
        Operators:
            white_move()
        Path Cost:
            Number of White Moves (1 per move)


2.2 What search algorithm does your program use?
    It determines the lowest manhattan distance between white pieces and
2.3 If applicable, what is the branching factor of your search tree?

2.4 What is the maximum search depth?

2.5 Does your algorithm always return the shortest possible sequence of moves that will eliminate all enemy pieces?
    No as some sequences require positions that are in 'taken' positions to jump, which the algorithm won't search for. (probably)
